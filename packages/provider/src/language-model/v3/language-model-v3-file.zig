const std = @import("std");
const shared = @import("../../shared/v3/index.zig");

/// A file that has been generated by the model.
/// Generated files as base64 encoded strings or binary data.
/// The files should be returned without any unnecessary conversion.
pub const LanguageModelV3File = struct {
    /// The type identifier (always "file")
    type: Type = .file,

    /// The IANA media type of the file, e.g. `image/png` or `audio/mp3`.
    /// @see https://www.iana.org/assignments/media-types/media-types.xhtml
    media_type: []const u8,

    /// Generated file data as base64 encoded strings or binary data.
    /// The file data should be returned without any unnecessary conversion.
    /// If the API returns base64 encoded strings, the file data should be returned
    /// as base64 encoded strings. If the API returns binary data, the file data should
    /// be returned as binary data.
    data: FileData,

    /// Optional provider-specific metadata for the file part.
    provider_metadata: ?shared.SharedV3ProviderMetadata = null,

    pub const Type = enum {
        file,

        pub fn toString(self: Type) []const u8 {
            return switch (self) {
                .file => "file",
            };
        }
    };

    /// File data can be either base64 encoded string or raw binary data
    pub const FileData = union(enum) {
        /// Base64 encoded string
        base64: []const u8,
        /// Raw binary data
        binary: []const u8,

        /// Get the data as bytes (decodes base64 if needed)
        pub fn asBytes(self: FileData, allocator: std.mem.Allocator) ![]const u8 {
            return switch (self) {
                .base64 => |b64| {
                    const decoder = std.base64.standard.Decoder;
                    const decoded_len = decoder.calcSizeForSlice(b64) catch return error.InvalidBase64;
                    const decoded = try allocator.alloc(u8, decoded_len);
                    decoder.decode(decoded, b64) catch {
                        allocator.free(decoded);
                        return error.InvalidBase64;
                    };
                    return decoded;
                },
                .binary => |data| try allocator.dupe(u8, data),
            };
        }

        /// Clone the file data
        pub fn clone(self: FileData, allocator: std.mem.Allocator) !FileData {
            return switch (self) {
                .base64 => |b64| .{ .base64 = try allocator.dupe(u8, b64) },
                .binary => |data| .{ .binary = try allocator.dupe(u8, data) },
            };
        }

        /// Free memory
        pub fn deinit(self: *FileData, allocator: std.mem.Allocator) void {
            switch (self.*) {
                .base64 => |b64| allocator.free(b64),
                .binary => |data| allocator.free(data),
            }
        }
    };

    const Self = @This();

    /// Create a new file from base64 data
    pub fn initBase64(media_type: []const u8, base64_data: []const u8) Self {
        return .{
            .media_type = media_type,
            .data = .{ .base64 = base64_data },
        };
    }

    /// Create a new file from binary data
    pub fn initBinary(media_type: []const u8, binary_data: []const u8) Self {
        return .{
            .media_type = media_type,
            .data = .{ .binary = binary_data },
        };
    }

    /// Clone the file
    pub fn clone(self: Self, allocator: std.mem.Allocator) !Self {
        return .{
            .type = self.type,
            .media_type = try allocator.dupe(u8, self.media_type),
            .data = try self.data.clone(allocator),
            .provider_metadata = if (self.provider_metadata) |pm| try pm.clone(allocator) else null,
        };
    }

    /// Free memory allocated for this file
    pub fn deinit(self: *Self, allocator: std.mem.Allocator) void {
        allocator.free(self.media_type);
        self.data.deinit(allocator);
        if (self.provider_metadata) |*pm| {
            pm.deinit();
        }
    }
};

test "LanguageModelV3File base64" {
    const file = LanguageModelV3File.initBase64("image/png", "SGVsbG8gV29ybGQ=");
    try std.testing.expectEqualStrings("image/png", file.media_type);
    try std.testing.expectEqual(LanguageModelV3File.Type.file, file.type);
}

test "LanguageModelV3File binary" {
    const file = LanguageModelV3File.initBinary("application/octet-stream", &[_]u8{ 0x00, 0x01, 0x02 });
    try std.testing.expectEqualStrings("application/octet-stream", file.media_type);
}
